// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class NewRelease extends ethereum.Event {
  get params(): NewRelease__Params {
    return new NewRelease__Params(this);
  }
}

export class NewRelease__Params {
  _event: NewRelease;

  constructor(event: NewRelease) {
    this._event = event;
  }

  get release_id(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get template(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get api_version(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class NewVault extends ethereum.Event {
  get params(): NewVault__Params {
    return new NewVault__Params(this);
  }
}

export class NewVault__Params {
  _event: NewVault;

  constructor(event: NewVault) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get deployment_id(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get vault(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get api_version(): string {
    return this._event.parameters[3].value.toString();
  }
}

export class NewExperimentalVault extends ethereum.Event {
  get params(): NewExperimentalVault__Params {
    return new NewExperimentalVault__Params(this);
  }
}

export class NewExperimentalVault__Params {
  _event: NewExperimentalVault;

  constructor(event: NewExperimentalVault) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get deployer(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get vault(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get api_version(): string {
    return this._event.parameters[3].value.toString();
  }
}

export class NewGovernance extends ethereum.Event {
  get params(): NewGovernance__Params {
    return new NewGovernance__Params(this);
  }
}

export class NewGovernance__Params {
  _event: NewGovernance;

  constructor(event: NewGovernance) {
    this._event = event;
  }

  get governance(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class VaultTagged extends ethereum.Event {
  get params(): VaultTagged__Params {
    return new VaultTagged__Params(this);
  }
}

export class VaultTagged__Params {
  _event: VaultTagged;

  constructor(event: VaultTagged) {
    this._event = event;
  }

  get vault(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get tag(): string {
    return this._event.parameters[1].value.toString();
  }
}

export class Registry extends ethereum.SmartContract {
  static bind(address: Address): Registry {
    return new Registry("Registry", address);
  }

  latestRelease(): string {
    let result = super.call("latestRelease", "latestRelease():(string)", []);

    return result[0].toString();
  }

  try_latestRelease(): ethereum.CallResult<string> {
    let result = super.tryCall("latestRelease", "latestRelease():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  latestVault(token: Address): Address {
    let result = super.call("latestVault", "latestVault(address):(address)", [
      ethereum.Value.fromAddress(token)
    ]);

    return result[0].toAddress();
  }

  try_latestVault(token: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "latestVault",
      "latestVault(address):(address)",
      [ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  newVault(
    token: Address,
    guardian: Address,
    rewards: Address,
    name: string,
    symbol: string
  ): Address {
    let result = super.call(
      "newVault",
      "newVault(address,address,address,string,string):(address)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(guardian),
        ethereum.Value.fromAddress(rewards),
        ethereum.Value.fromString(name),
        ethereum.Value.fromString(symbol)
      ]
    );

    return result[0].toAddress();
  }

  try_newVault(
    token: Address,
    guardian: Address,
    rewards: Address,
    name: string,
    symbol: string
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "newVault",
      "newVault(address,address,address,string,string):(address)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(guardian),
        ethereum.Value.fromAddress(rewards),
        ethereum.Value.fromString(name),
        ethereum.Value.fromString(symbol)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  newExperimentalVault(
    token: Address,
    governance: Address,
    guardian: Address,
    rewards: Address,
    name: string,
    symbol: string
  ): Address {
    let result = super.call(
      "newExperimentalVault",
      "newExperimentalVault(address,address,address,address,string,string):(address)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(governance),
        ethereum.Value.fromAddress(guardian),
        ethereum.Value.fromAddress(rewards),
        ethereum.Value.fromString(name),
        ethereum.Value.fromString(symbol)
      ]
    );

    return result[0].toAddress();
  }

  try_newExperimentalVault(
    token: Address,
    governance: Address,
    guardian: Address,
    rewards: Address,
    name: string,
    symbol: string
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "newExperimentalVault",
      "newExperimentalVault(address,address,address,address,string,string):(address)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(governance),
        ethereum.Value.fromAddress(guardian),
        ethereum.Value.fromAddress(rewards),
        ethereum.Value.fromString(name),
        ethereum.Value.fromString(symbol)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  nextRelease(): BigInt {
    let result = super.call("nextRelease", "nextRelease():(uint256)", []);

    return result[0].toBigInt();
  }

  try_nextRelease(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nextRelease", "nextRelease():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  releases(arg0: BigInt): Address {
    let result = super.call("releases", "releases(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(arg0)
    ]);

    return result[0].toAddress();
  }

  try_releases(arg0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("releases", "releases(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(arg0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  nextDeployment(arg0: Address): BigInt {
    let result = super.call(
      "nextDeployment",
      "nextDeployment(address):(uint256)",
      [ethereum.Value.fromAddress(arg0)]
    );

    return result[0].toBigInt();
  }

  try_nextDeployment(arg0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "nextDeployment",
      "nextDeployment(address):(uint256)",
      [ethereum.Value.fromAddress(arg0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  vaults(arg0: Address, arg1: BigInt): Address {
    let result = super.call("vaults", "vaults(address,uint256):(address)", [
      ethereum.Value.fromAddress(arg0),
      ethereum.Value.fromUnsignedBigInt(arg1)
    ]);

    return result[0].toAddress();
  }

  try_vaults(arg0: Address, arg1: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("vaults", "vaults(address,uint256):(address)", [
      ethereum.Value.fromAddress(arg0),
      ethereum.Value.fromUnsignedBigInt(arg1)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  governance(): Address {
    let result = super.call("governance", "governance():(address)", []);

    return result[0].toAddress();
  }

  try_governance(): ethereum.CallResult<Address> {
    let result = super.tryCall("governance", "governance():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  tags(arg0: Address): string {
    let result = super.call("tags", "tags(address):(string)", [
      ethereum.Value.fromAddress(arg0)
    ]);

    return result[0].toString();
  }

  try_tags(arg0: Address): ethereum.CallResult<string> {
    let result = super.tryCall("tags", "tags(address):(string)", [
      ethereum.Value.fromAddress(arg0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  banksy(arg0: Address): boolean {
    let result = super.call("banksy", "banksy(address):(bool)", [
      ethereum.Value.fromAddress(arg0)
    ]);

    return result[0].toBoolean();
  }

  try_banksy(arg0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("banksy", "banksy(address):(bool)", [
      ethereum.Value.fromAddress(arg0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class SetGovernanceCall extends ethereum.Call {
  get inputs(): SetGovernanceCall__Inputs {
    return new SetGovernanceCall__Inputs(this);
  }

  get outputs(): SetGovernanceCall__Outputs {
    return new SetGovernanceCall__Outputs(this);
  }
}

export class SetGovernanceCall__Inputs {
  _call: SetGovernanceCall;

  constructor(call: SetGovernanceCall) {
    this._call = call;
  }

  get governance(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetGovernanceCall__Outputs {
  _call: SetGovernanceCall;

  constructor(call: SetGovernanceCall) {
    this._call = call;
  }
}

export class AcceptGovernanceCall extends ethereum.Call {
  get inputs(): AcceptGovernanceCall__Inputs {
    return new AcceptGovernanceCall__Inputs(this);
  }

  get outputs(): AcceptGovernanceCall__Outputs {
    return new AcceptGovernanceCall__Outputs(this);
  }
}

export class AcceptGovernanceCall__Inputs {
  _call: AcceptGovernanceCall;

  constructor(call: AcceptGovernanceCall) {
    this._call = call;
  }
}

export class AcceptGovernanceCall__Outputs {
  _call: AcceptGovernanceCall;

  constructor(call: AcceptGovernanceCall) {
    this._call = call;
  }
}

export class NewReleaseCall extends ethereum.Call {
  get inputs(): NewReleaseCall__Inputs {
    return new NewReleaseCall__Inputs(this);
  }

  get outputs(): NewReleaseCall__Outputs {
    return new NewReleaseCall__Outputs(this);
  }
}

export class NewReleaseCall__Inputs {
  _call: NewReleaseCall;

  constructor(call: NewReleaseCall) {
    this._call = call;
  }

  get vault(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class NewReleaseCall__Outputs {
  _call: NewReleaseCall;

  constructor(call: NewReleaseCall) {
    this._call = call;
  }
}

export class NewVaultCall extends ethereum.Call {
  get inputs(): NewVaultCall__Inputs {
    return new NewVaultCall__Inputs(this);
  }

  get outputs(): NewVaultCall__Outputs {
    return new NewVaultCall__Outputs(this);
  }
}

export class NewVaultCall__Inputs {
  _call: NewVaultCall;

  constructor(call: NewVaultCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get guardian(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get rewards(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get name(): string {
    return this._call.inputValues[3].value.toString();
  }

  get symbol(): string {
    return this._call.inputValues[4].value.toString();
  }
}

export class NewVaultCall__Outputs {
  _call: NewVaultCall;

  constructor(call: NewVaultCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class NewExperimentalVaultCall extends ethereum.Call {
  get inputs(): NewExperimentalVaultCall__Inputs {
    return new NewExperimentalVaultCall__Inputs(this);
  }

  get outputs(): NewExperimentalVaultCall__Outputs {
    return new NewExperimentalVaultCall__Outputs(this);
  }
}

export class NewExperimentalVaultCall__Inputs {
  _call: NewExperimentalVaultCall;

  constructor(call: NewExperimentalVaultCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get governance(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get guardian(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get rewards(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get name(): string {
    return this._call.inputValues[4].value.toString();
  }

  get symbol(): string {
    return this._call.inputValues[5].value.toString();
  }
}

export class NewExperimentalVaultCall__Outputs {
  _call: NewExperimentalVaultCall;

  constructor(call: NewExperimentalVaultCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class EndorseVaultCall extends ethereum.Call {
  get inputs(): EndorseVaultCall__Inputs {
    return new EndorseVaultCall__Inputs(this);
  }

  get outputs(): EndorseVaultCall__Outputs {
    return new EndorseVaultCall__Outputs(this);
  }
}

export class EndorseVaultCall__Inputs {
  _call: EndorseVaultCall;

  constructor(call: EndorseVaultCall) {
    this._call = call;
  }

  get vault(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class EndorseVaultCall__Outputs {
  _call: EndorseVaultCall;

  constructor(call: EndorseVaultCall) {
    this._call = call;
  }
}

export class SetBanksyCall extends ethereum.Call {
  get inputs(): SetBanksyCall__Inputs {
    return new SetBanksyCall__Inputs(this);
  }

  get outputs(): SetBanksyCall__Outputs {
    return new SetBanksyCall__Outputs(this);
  }
}

export class SetBanksyCall__Inputs {
  _call: SetBanksyCall;

  constructor(call: SetBanksyCall) {
    this._call = call;
  }

  get tagger(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetBanksyCall__Outputs {
  _call: SetBanksyCall;

  constructor(call: SetBanksyCall) {
    this._call = call;
  }
}

export class SetBanksy1Call extends ethereum.Call {
  get inputs(): SetBanksy1Call__Inputs {
    return new SetBanksy1Call__Inputs(this);
  }

  get outputs(): SetBanksy1Call__Outputs {
    return new SetBanksy1Call__Outputs(this);
  }
}

export class SetBanksy1Call__Inputs {
  _call: SetBanksy1Call;

  constructor(call: SetBanksy1Call) {
    this._call = call;
  }

  get tagger(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get allowed(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetBanksy1Call__Outputs {
  _call: SetBanksy1Call;

  constructor(call: SetBanksy1Call) {
    this._call = call;
  }
}

export class TagVaultCall extends ethereum.Call {
  get inputs(): TagVaultCall__Inputs {
    return new TagVaultCall__Inputs(this);
  }

  get outputs(): TagVaultCall__Outputs {
    return new TagVaultCall__Outputs(this);
  }
}

export class TagVaultCall__Inputs {
  _call: TagVaultCall;

  constructor(call: TagVaultCall) {
    this._call = call;
  }

  get vault(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tag(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class TagVaultCall__Outputs {
  _call: TagVaultCall;

  constructor(call: TagVaultCall) {
    this._call = call;
  }
}
